//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace Tapio.Tadamo.Clients.WebApi
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface ITadamoApiClient
    {

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the instance by id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="instanceId">The id of the instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InstanceData> GetInstanceByIdAsync(System.Guid subscriptionId, System.Guid instanceId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves multiple private instances by their ids
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">Specifies the instances to retrieve.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfInstanceData> GetMyInstancesByIdAsync(System.Guid subscriptionId, GetInstancesRequest body, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates an adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="body">Instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> CreateAdapterAsync(System.Guid subscriptionId, InstanceDataCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the adapter by external id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="externalId">The externalId of the adapter item, when external id is set all private and public data will be searched for the instance data</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Adapter> GetAdapterByExternalIdAsync(System.Guid subscriptionId, string externalId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the adapter item that needs to be deleted</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteAdapterAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets TADAMO adapter item by internal id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the adapter item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Adapter> GetAdapterByIdAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an adapters properties
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">The unique id of the adapter.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the instance data.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateAdapterByIdAsync(System.Guid subscriptionId, System.Guid id, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer ownership of an adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The request of transferring ownership</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Owner is updated</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> TransferAdapterOwnershipAsync(System.Guid subscriptionId, TransferOwnershipRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets a template of the requested adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="masterDataOwnerId">id of the owner of master data</param>
        /// <param name="masterdataId">id of the masterdata for which a template should be returned</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="version">version for the schema used to generate the template.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InstanceDataTemplate> GetAdapterTemplateAsync(System.Guid subscriptionId, System.Guid masterDataOwnerId, System.Guid masterdataId, System.Guid? subjectSubscriptionId = null, string version = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an adapters state by id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="instanceDataId">id of the adpater which should be changed</param>
        /// <param name="body">Adapter state update request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChangeAdapterStateByIdAsync(System.Guid subscriptionId, System.Guid instanceDataId, InstanceDateStateUpdate body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs an instance data item to given space
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="spaceId">SpaceId to which instance item should be plugged</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PlugAdapterToSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid spaceId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes an instance data from its location.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveAdapterFromSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the types for adapters in the system.
        /// </summary>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfTypeInformation> GetAdapterTypesAsync(string subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves an number of instances by subscriptionId.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<int> GetAdaptersCountAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all locations which are owned by subscription.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfSpace> GetLocationsAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates master data item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="body">Master data item.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> CreateMasterDataItemAsync(System.Guid subscriptionId, MasterDataCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets TADAMO master data item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">ID of master data item.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Masterdata> GetMasterDataItemByIdAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a masterdata item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">The unique id of the masterdata item.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the masterdata.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateMasterDataItemByIdAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes TADAMO master data item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">ID of the master data item that needs to be deleted.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMasterDataItemAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates blob for TADAMO master data item
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="content_Type">"image/jpg", "image/jpeg", "image/png", "image/tiff", "image/tif"</param>
        /// <param name="masterDataId">Master data id</param>
        /// <param name="blobType">Type of blob</param>
        /// <param name="culture">The culture of the blob</param>
        /// <param name="body">The content of the request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="name">Optional. The name of the blob.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> CreateMasterDataItemBlobAsync(System.Guid subscriptionId, string content_Type, System.Guid masterDataId, System.Guid blobType, string culture, FileParameter body, System.Guid? subjectSubscriptionId = null, string name = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete blob of master data item
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">Id of the master data item</param>
        /// <param name="blobId">Blob id</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMasterDataItemBlobAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Guid blobId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="body">Material create request.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> CreateMaterialAsync(System.Guid subscriptionId, InstanceDataCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the material by external id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="externalId">The material of the instance data item, when external id is set all private and public data will be searched for the material</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Material> GetMaterialByExternalIdAsync(System.Guid subscriptionId, string externalId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the material that needs to be deleted</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteMaterialAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets a material by internal id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the material.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Material> GetMaterialByIdAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a materials properties
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">The unique id of the material.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the instance data.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateMaterialByIdAsync(System.Guid subscriptionId, System.Guid id, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer ownership of a material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The request of transferring ownership</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Owner is updated</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> TransferMaterialOwnershipAsync(System.Guid subscriptionId, TransferOwnershipRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets template of the requested material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="masterDataOwnerId">id of the owner of master data</param>
        /// <param name="masterdataId">id of the masterdata for which a template should be returned</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="version">version for the schema used to generate the template.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InstanceDataTemplate> GetMaterialTemplateAsync(System.Guid subscriptionId, System.Guid masterDataOwnerId, System.Guid masterdataId, System.Guid? subjectSubscriptionId = null, string version = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a materials state.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="instanceDataId">id of the material which should be changed</param>
        /// <param name="body">The material state update request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChangeMaterialStateByIdAsync(System.Guid subscriptionId, System.Guid instanceDataId, InstanceDateStateUpdate body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs an material to given space
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the material.</param>
        /// <param name="spaceId">SpaceId to which the material should be plugged</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PlugMaterialToSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid spaceId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes an instance data from its location.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveMaterialFromSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the types for materials in the system.
        /// </summary>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfTypeInformation> GetMaterialTypesAsync(string subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves an number of instances by subscriptionId.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<int> GetMaterialsCountAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="tapioMachineId">Machine which produces processdata with tool.</param>
        /// <param name="toolId">Id of the tool to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostProcessDataMessageForMachineAsync(System.Guid subscriptionId, string tapioMachineId, System.Guid toolId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="toolId">Id of the tool to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostProcessDataMessageAsync(System.Guid subscriptionId, System.Guid toolId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="tapioMachineId">Machine which produces processdata with tool.</param>
        /// <param name="materialId">Id of the material to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostProcessDataMessageForMaterialForMachineAsync(System.Guid subscriptionId, string tapioMachineId, System.Guid materialId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="materialId">Id of the tool to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PostProcessDataMessageForMaterialAsync(System.Guid subscriptionId, System.Guid materialId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all sharpening services related to subscription.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription in which scope tool is created.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfSharpeningService> GetSharpeningServicesAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO schemas filtered by type, subtype parameters
        /// </summary>
        /// <param name="typeId">The type id of TADAMO</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfSchema> GetSystemSchemasAsync(System.Guid typeId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO schemas for a specified type.
        /// </summary>
        /// <param name="typeId">The id of the type.</param>
        /// <param name="versionPrefix">Version prefix that is used to match the schemas.
        /// <br/>            1. All matching schemas are returned e.g. 1.1 will return 1.1.0, 1.1.1, etc.
        /// <br/>            2. For an empty prefix, all available schemas are returned.
        /// <br/>            3. The special prefix 'latest' will return only the newest schemas.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfSystemSchemas> GetSystemTypeSchemasAsync(System.Guid typeId, string versionPrefix = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO types which are supported by system
        /// </summary>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfTypeInformation> GetSystemTypesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO types which are supported by system
        /// </summary>
        /// <param name="id">The type id of TADAMO</param>
        /// <param name="traverse">The traversal direction</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfTypeInformation> GetSystemTypesByIdAsync(System.Guid id, TraversalDirection? traverse = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO blob types which are supported by system
        /// </summary>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfBlobTypeInformation> GetSystemBlobTypesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription in which scope tool is created.</param>
        /// <param name="body">The tool creation request.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> CreateToolAsync(System.Guid subscriptionId, InstanceDataCreateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the a tool by external id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="externalId">The externalId of the tool when external id is set all private and public data will be searched for the tool</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Tool> GetToolByExternalIdAsync(System.Guid subscriptionId, string externalId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets a tool by internal id.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="id">The id of the tool.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Tool> GetToolByIdAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="id">The id of the tool that needs to be deleted.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteToolAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the tool.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="id">Id of the tool to plug.</param>
        /// <param name="body">Patch operation to apply.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>NoContent - Patch was successfully applied.</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateToolByIdAsync(System.Guid subscriptionId, System.Guid id, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Begin Sharpening of the tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="toolId">The id of the tool.</param>
        /// <param name="body">The sharpening service request.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Sharpening is started</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task BeginToolSharpeningAsync(System.Guid subscriptionId, System.Guid toolId, BeginSharpeningRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// End Sharpening of the tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="toolId">The id of the tool.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Sharpening is ended</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task EndToolSharpeningAsync(System.Guid subscriptionId, System.Guid toolId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abort Sharpening of the tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="toolId">The id of the tool.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Sharpening is ended</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AbortToolSharpeningAsync(System.Guid subscriptionId, System.Guid toolId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs the tool to the given machine.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="toolId">Id of the tool to plug.</param>
        /// <param name="tapioMachineId">TapioMachineId of the machine to which the item will be plugged.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok - Tool was plugged into machine</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PlugToolToMachineAsync(System.Guid subscriptionId, System.Guid toolId, string tapioMachineId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes the tool from a machine.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="toolId">Id of the tool to plug.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok - Tool was removed from machine.</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UnplugToolFromMachineAsync(System.Guid subscriptionId, System.Guid toolId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer ownership of a tool.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The request of transferring ownership</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Owner is updated</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<System.Guid> TransferToolOwnershipAsync(System.Guid subscriptionId, TransferOwnershipRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets template of the requested tool.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="masterDataOwnerId">id of the owner of master data</param>
        /// <param name="masterdataId">id of the masterdata for which a template should be returned</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="version">version for the schema used to generate the template.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InstanceDataTemplate> GetToolTemplateAsync(System.Guid subscriptionId, System.Guid masterDataOwnerId, System.Guid masterdataId, System.Guid? subjectSubscriptionId = null, string version = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets template of the requested tool.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="toolId">id of the type of tool for which an aggregation template should be returned</param>
        /// <param name="body">aggregation template request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<AggregationTemplate> GetAggregationTemplateAsync(System.Guid subscriptionId, System.Guid toolId, AggregationTemplateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a tools state
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="instanceDataId">id of the instancedata which should be changed</param>
        /// <param name="body">Instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ChangeToolStateByIdAsync(System.Guid subscriptionId, System.Guid instanceDataId, InstanceDateStateUpdate body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a tools aggregation properties
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="toolId">The unique id of the tool.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the instance data.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task UpdateAggregationByToolIdAsync(System.Guid subscriptionId, System.Guid toolId, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs an instance data item to given space
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="spaceId">SpaceId to which instance item should be plugged</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task PlugToolToSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid spaceId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes an instance data from its location.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task RemoveToolFromSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Aggregates tool with other instance
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the tool</param>
        /// <param name="body">The aggregation create request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task AggregateToolWithOtherInstanceAsync(System.Guid subscriptionId, System.Guid id, AggregationCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Disaggregates tool and other instance
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the tool</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DisaggregateToolAndOtherInstanceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the types for tools in the system.
        /// </summary>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfTypeInformation> GetToolTypesAsync(string subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves an number of instances by subscriptionId.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<int> GetToolsCountAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Search for instances.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The search request.</param>
        /// <param name="expectedLanguage">The header, which contains expectedLanguage will be used to return the manufacturer specific translation</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchListResultResponseOfSearchInstanceData> SearchInstanceDataAsync(System.Guid subscriptionId, GetSearchInstanceData body, string expectedLanguage = null, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Search for manufacturers in TADAMO.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="search">The value to search.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="offset">Number of items to skip.</param>
        /// <param name="limit">Maximum number of items returned.</param>
        /// <param name="manufacturerKindFilter">Parameter to filter the result by manufacturer kind.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ResultOfSearchManufacturer> SearchManufacturersAsync(System.Guid subscriptionId, string search, System.Guid? subjectSubscriptionId = null, int? offset = null, int? limit = null, ManufacturerKindFilter? manufacturerKindFilter = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Search for masterdata.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="body">Request defining what to search</param>
        /// <param name="expectedLanguage">The header, which contains expectedLanguage will be used to return the manufacturer specific translation</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchListResultResponseOfSearchMasterData> SearchMasterDataAsync(System.Guid subscriptionId, GetSearchMasterData body, string expectedLanguage = null, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets TADAMO instance data item by internal id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="instanceId">ID of instance item</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task GetEtmlInstanceByIdAsync(System.Guid subscriptionId, System.Guid instanceId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves historical instance data.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which data to retrieve.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricalListResponseOfHistoricalInstanceData> RequestHistoricalInstanceDataAsync(System.Guid subscriptionId, HistoricalInstanceDataRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves sharpening cycles for instances.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which cycles to retrieve.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricalListResponseOfSharpeningCycle> RequestSharpeningCyclesAsync(System.Guid subscriptionId, GetSharpeningCyclesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Aggregates a parameter by sharpening cycles.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which parameter to aggregate.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricalListResponseOfSharpeningCycleAggregation> AggregateBySharpeningCyclesAsync(System.Guid subscriptionId, AggregateBySharpeningCycleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves the date when the instance was last put into sharpening.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which data to retrieve.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<HistoricalListResponseOfHistoricalDate> RequestLastBeginSharpeningDateAsync(System.Guid subscriptionId, GetDateOfLastSharpeningBeginRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TadamoApiClient : ITadamoApiClient
    {
        private string _baseUrl = "";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public TadamoApiClient(string baseUrl, System.Net.Http.HttpClient httpClient)
        {
            BaseUrl = baseUrl;
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the instance by id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="instanceId">The id of the instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InstanceData> GetInstanceByIdAsync(System.Guid subscriptionId, System.Guid instanceId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (instanceId == null)
                throw new System.ArgumentNullException("instanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/instancedata/{instanceId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceId}", System.Uri.EscapeDataString(ConvertToString(instanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InstanceData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves multiple private instances by their ids
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">Specifies the instances to retrieve.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfInstanceData> GetMyInstancesByIdAsync(System.Guid subscriptionId, GetInstancesRequest body, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/instancedata/my");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfInstanceData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates an adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="body">Instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> CreateAdapterAsync(System.Guid subscriptionId, InstanceDataCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the adapter by external id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="externalId">The externalId of the adapter item, when external id is set all private and public data will be searched for the instance data</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Adapter> GetAdapterByExternalIdAsync(System.Guid subscriptionId, string externalId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (externalId == null)
                throw new System.ArgumentNullException("externalId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("externalId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(externalId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Adapter>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this adapter", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Conflict - There is no clear match for external id", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes an adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the adapter item that needs to be deleted</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteAdapterAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this adapter", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets TADAMO adapter item by internal id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the adapter item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Adapter> GetAdapterByIdAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Adapter>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this adpater.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an adapters properties
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">The unique id of the adapter.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the instance data.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateAdapterByIdAsync(System.Guid subscriptionId, System.Guid id, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this adapter.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer ownership of an adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The request of transferring ownership</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Owner is updated</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> TransferAdapterOwnershipAsync(System.Guid subscriptionId, TransferOwnershipRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/transferownership");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 204)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("NoContent - Already owned by owner", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized - No valid authorization header", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this tool", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets a template of the requested adapter.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="masterDataOwnerId">id of the owner of master data</param>
        /// <param name="masterdataId">id of the masterdata for which a template should be returned</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="version">version for the schema used to generate the template.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InstanceDataTemplate> GetAdapterTemplateAsync(System.Guid subscriptionId, System.Guid masterDataOwnerId, System.Guid masterdataId, System.Guid? subjectSubscriptionId = null, string version = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataOwnerId == null)
                throw new System.ArgumentNullException("masterDataOwnerId");

            if (masterdataId == null)
                throw new System.ArgumentNullException("masterdataId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/template?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("masterDataOwnerId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(masterDataOwnerId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append(System.Uri.EscapeDataString("masterdataId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(masterdataId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (version != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("version") + "=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InstanceDataTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates an adapters state by id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="instanceDataId">id of the adpater which should be changed</param>
        /// <param name="body">Adapter state update request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ChangeAdapterStateByIdAsync(System.Guid subscriptionId, System.Guid instanceDataId, InstanceDateStateUpdate body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (instanceDataId == null)
                throw new System.ArgumentNullException("instanceDataId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/{instanceDataId}/state");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceDataId}", System.Uri.EscapeDataString(ConvertToString(instanceDataId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs an instance data item to given space
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="spaceId">SpaceId to which instance item should be plugged</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PlugAdapterToSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid spaceId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            if (spaceId == null)
                throw new System.ArgumentNullException("spaceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/{id}/spaces/{spaceId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{spaceId}", System.Uri.EscapeDataString(ConvertToString(spaceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes an instance data from its location.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveAdapterFromSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/{id}/spaces");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the types for adapters in the system.
        /// </summary>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfTypeInformation> GetAdapterTypesAsync(string subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/types");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ResultOfTypeInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves an number of instances by subscriptionId.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<int> GetAdaptersCountAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/adapters/count");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<int>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all locations which are owned by subscription.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfSpace> GetLocationsAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/locations");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfSpace>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates master data item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="body">Master data item.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> CreateMasterDataItemAsync(System.Guid subscriptionId, MasterDataCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/masterdata");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets TADAMO master data item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">ID of master data item.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Masterdata> GetMasterDataItemByIdAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataId == null)
                throw new System.ArgumentNullException("masterDataId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/masterdata/{masterDataId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{masterDataId}", System.Uri.EscapeDataString(ConvertToString(masterDataId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Masterdata>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a masterdata item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">The unique id of the masterdata item.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the masterdata.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateMasterDataItemByIdAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataId == null)
                throw new System.ArgumentNullException("masterDataId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/masterdata/{masterDataId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{masterDataId}", System.Uri.EscapeDataString(ConvertToString(masterDataId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller is not allowed to update this masterdata.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes TADAMO master data item.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">ID of the master data item that needs to be deleted.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteMasterDataItemAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataId == null)
                throw new System.ArgumentNullException("masterDataId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/masterdata/{masterDataId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{masterDataId}", System.Uri.EscapeDataString(ConvertToString(masterDataId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates blob for TADAMO master data item
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="content_Type">"image/jpg", "image/jpeg", "image/png", "image/tiff", "image/tif"</param>
        /// <param name="masterDataId">Master data id</param>
        /// <param name="blobType">Type of blob</param>
        /// <param name="culture">The culture of the blob</param>
        /// <param name="body">The content of the request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="name">Optional. The name of the blob.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> CreateMasterDataItemBlobAsync(System.Guid subscriptionId, string content_Type, System.Guid masterDataId, System.Guid blobType, string culture, FileParameter body, System.Guid? subjectSubscriptionId = null, string name = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataId == null)
                throw new System.ArgumentNullException("masterDataId");

            if (blobType == null)
                throw new System.ArgumentNullException("blobType");

            if (culture == null)
                throw new System.ArgumentNullException("culture");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/masterdata/{masterDataId}/blobs?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{masterDataId}", System.Uri.EscapeDataString(ConvertToString(masterDataId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("blobType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(blobType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append(System.Uri.EscapeDataString("culture") + "=").Append(System.Uri.EscapeDataString(ConvertToString(culture, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (content_Type == null)
                        throw new System.ArgumentNullException("content_Type");
                    request_.Headers.TryAddWithoutValidation("Content-Type", ConvertToString(content_Type, System.Globalization.CultureInfo.InvariantCulture));

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StreamContent(body.Data);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse(body.ContentType);
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete blob of master data item
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="masterDataId">Id of the master data item</param>
        /// <param name="blobId">Blob id</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteMasterDataItemBlobAsync(System.Guid subscriptionId, System.Guid masterDataId, System.Guid blobId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataId == null)
                throw new System.ArgumentNullException("masterDataId");

            if (blobId == null)
                throw new System.ArgumentNullException("blobId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/masterdata/{masterDataId}/blobs/{blobId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{masterDataId}", System.Uri.EscapeDataString(ConvertToString(masterDataId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{blobId}", System.Uri.EscapeDataString(ConvertToString(blobId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="body">Material create request.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> CreateMaterialAsync(System.Guid subscriptionId, InstanceDataCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the material by external id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="externalId">The material of the instance data item, when external id is set all private and public data will be searched for the material</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Material> GetMaterialByExternalIdAsync(System.Guid subscriptionId, string externalId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (externalId == null)
                throw new System.ArgumentNullException("externalId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("externalId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(externalId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Material>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this material", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Conflict - There is no clear match for external id", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes a material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the material that needs to be deleted</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteMaterialAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this instance data", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets a material by internal id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the material.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Material> GetMaterialByIdAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Material>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this material", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a materials properties
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">The unique id of the material.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the instance data.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateMaterialByIdAsync(System.Guid subscriptionId, System.Guid id, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this material", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer ownership of a material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The request of transferring ownership</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Owner is updated</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> TransferMaterialOwnershipAsync(System.Guid subscriptionId, TransferOwnershipRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/transferownership");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 204)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("NoContent - Already owned by owner", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized - No valid authorization header", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this tool", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets template of the requested material.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="masterDataOwnerId">id of the owner of master data</param>
        /// <param name="masterdataId">id of the masterdata for which a template should be returned</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="version">version for the schema used to generate the template.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InstanceDataTemplate> GetMaterialTemplateAsync(System.Guid subscriptionId, System.Guid masterDataOwnerId, System.Guid masterdataId, System.Guid? subjectSubscriptionId = null, string version = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataOwnerId == null)
                throw new System.ArgumentNullException("masterDataOwnerId");

            if (masterdataId == null)
                throw new System.ArgumentNullException("masterdataId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/template?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("masterDataOwnerId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(masterDataOwnerId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append(System.Uri.EscapeDataString("masterdataId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(masterdataId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (version != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("version") + "=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InstanceDataTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a materials state.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="instanceDataId">id of the material which should be changed</param>
        /// <param name="body">The material state update request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ChangeMaterialStateByIdAsync(System.Guid subscriptionId, System.Guid instanceDataId, InstanceDateStateUpdate body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (instanceDataId == null)
                throw new System.ArgumentNullException("instanceDataId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/{instanceDataId}/state");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceDataId}", System.Uri.EscapeDataString(ConvertToString(instanceDataId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs an material to given space
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the material.</param>
        /// <param name="spaceId">SpaceId to which the material should be plugged</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PlugMaterialToSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid spaceId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            if (spaceId == null)
                throw new System.ArgumentNullException("spaceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/{id}/spaces/{spaceId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{spaceId}", System.Uri.EscapeDataString(ConvertToString(spaceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes an instance data from its location.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveMaterialFromSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/{id}/spaces");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the types for materials in the system.
        /// </summary>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfTypeInformation> GetMaterialTypesAsync(string subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/types");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ResultOfTypeInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves an number of instances by subscriptionId.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<int> GetMaterialsCountAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/count");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<int>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="tapioMachineId">Machine which produces processdata with tool.</param>
        /// <param name="toolId">Id of the tool to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostProcessDataMessageForMachineAsync(System.Guid subscriptionId, string tapioMachineId, System.Guid toolId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (tapioMachineId == null)
                throw new System.ArgumentNullException("tapioMachineId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/machines/{tapioMachineId}/tools/{toolId}/processdata");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tapioMachineId}", System.Uri.EscapeDataString(ConvertToString(tapioMachineId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="toolId">Id of the tool to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostProcessDataMessageAsync(System.Guid subscriptionId, System.Guid toolId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/processdata");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="tapioMachineId">Machine which produces processdata with tool.</param>
        /// <param name="materialId">Id of the material to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostProcessDataMessageForMaterialForMachineAsync(System.Guid subscriptionId, string tapioMachineId, System.Guid materialId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (tapioMachineId == null)
                throw new System.ArgumentNullException("tapioMachineId");

            if (materialId == null)
                throw new System.ArgumentNullException("materialId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/machines/{tapioMachineId}/materials/{materialId}/processdata");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tapioMachineId}", System.Uri.EscapeDataString(ConvertToString(tapioMachineId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{materialId}", System.Uri.EscapeDataString(ConvertToString(materialId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Posts processdata messages.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="materialId">Id of the tool to which the process data applies.</param>
        /// <param name="body">The process data messages.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Accepted - Messages were accepted</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostProcessDataMessageForMaterialAsync(System.Guid subscriptionId, System.Guid materialId, ProcessDataListRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (materialId == null)
                throw new System.ArgumentNullException("materialId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/materials/{materialId}/processdata");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{materialId}", System.Uri.EscapeDataString(ConvertToString(materialId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 202)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns all sharpening services related to subscription.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription in which scope tool is created.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfSharpeningService> GetSharpeningServicesAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/sharpeningservices");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfSharpeningService>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO schemas filtered by type, subtype parameters
        /// </summary>
        /// <param name="typeId">The type id of TADAMO</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfSchema> GetSystemSchemasAsync(System.Guid typeId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (typeId == null)
                throw new System.ArgumentNullException("typeId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/system/schemas?");
            urlBuilder_.Append(System.Uri.EscapeDataString("typeId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(typeId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfSchema>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO schemas for a specified type.
        /// </summary>
        /// <param name="typeId">The id of the type.</param>
        /// <param name="versionPrefix">Version prefix that is used to match the schemas.
        /// <br/>            1. All matching schemas are returned e.g. 1.1 will return 1.1.0, 1.1.1, etc.
        /// <br/>            2. For an empty prefix, all available schemas are returned.
        /// <br/>            3. The special prefix 'latest' will return only the newest schemas.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfSystemSchemas> GetSystemTypeSchemasAsync(System.Guid typeId, string versionPrefix = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (typeId == null)
                throw new System.ArgumentNullException("typeId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/system/types/{typeId}/schemas?");
            urlBuilder_.Replace("{typeId}", System.Uri.EscapeDataString(ConvertToString(typeId, System.Globalization.CultureInfo.InvariantCulture)));
            if (versionPrefix != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("versionPrefix") + "=").Append(System.Uri.EscapeDataString(ConvertToString(versionPrefix, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfSystemSchemas>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO types which are supported by system
        /// </summary>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfTypeInformation> GetSystemTypesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/system/types");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO types which are supported by system
        /// </summary>
        /// <param name="id">The type id of TADAMO</param>
        /// <param name="traverse">The traversal direction</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfTypeInformation> GetSystemTypesByIdAsync(System.Guid id, TraversalDirection? traverse = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/system/types/{id}?");
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
            if (traverse != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("traverse") + "=").Append(System.Uri.EscapeDataString(ConvertToString(traverse, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns TADAMO blob types which are supported by system
        /// </summary>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfBlobTypeInformation> GetSystemBlobTypesAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/system/blobtypes");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfBlobTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Creates a tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription in which scope tool is created.</param>
        /// <param name="body">The tool creation request.</param>
        /// <returns>Created</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> CreateToolAsync(System.Guid subscriptionId, InstanceDataCreateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get the a tool by external id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="externalId">The externalId of the tool when external id is set all private and public data will be searched for the tool</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Tool> GetToolByExternalIdAsync(System.Guid subscriptionId, string externalId, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (externalId == null)
                throw new System.ArgumentNullException("externalId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("externalId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(externalId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Tool>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this tool", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Conflict - There is no clear match for external id", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets a tool by internal id.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="id">The id of the tool.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="expectedLanguage">Expected-Language will be used to return the manufacturer specific translations.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Tool> GetToolByIdAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, string expectedLanguage = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Tool>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this tool.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Deletes tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="id">The id of the tool that needs to be deleted.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteToolAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this instance data", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates the tool.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="id">Id of the tool to plug.</param>
        /// <param name="body">Patch operation to apply.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>NoContent - Patch was successfully applied.</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateToolByIdAsync(System.Guid subscriptionId, System.Guid id, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{id}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Begin Sharpening of the tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="toolId">The id of the tool.</param>
        /// <param name="body">The sharpening service request.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Sharpening is started</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task BeginToolSharpeningAsync(System.Guid subscriptionId, System.Guid toolId, BeginSharpeningRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/beginsharpening");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized - No valid authorization header", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this instance data", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Conflict - Sharpening can not be started because the tool is plugged to machine", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// End Sharpening of the tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="toolId">The id of the tool.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Sharpening is ended</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task EndToolSharpeningAsync(System.Guid subscriptionId, System.Guid toolId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/endsharpening");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized - No valid authorization header", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this instance data", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Abort Sharpening of the tool.
        /// </summary>
        /// <param name="subscriptionId">The id of subscription.</param>
        /// <param name="toolId">The id of the tool.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Sharpening is ended</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task AbortToolSharpeningAsync(System.Guid subscriptionId, System.Guid toolId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/abortsharpening");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized - No valid authorization header", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this instance data", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs the tool to the given machine.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="toolId">Id of the tool to plug.</param>
        /// <param name="tapioMachineId">TapioMachineId of the machine to which the item will be plugged.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok - Tool was plugged into machine</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PlugToolToMachineAsync(System.Guid subscriptionId, System.Guid toolId, string tapioMachineId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            if (tapioMachineId == null)
                throw new System.ArgumentNullException("tapioMachineId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/machines/{tapioMachineId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{tapioMachineId}", System.Uri.EscapeDataString(ConvertToString(tapioMachineId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes the tool from a machine.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="toolId">Id of the tool to plug.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok - Tool was removed from machine.</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UnplugToolFromMachineAsync(System.Guid subscriptionId, System.Guid toolId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/machines");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Transfer ownership of a tool.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The request of transferring ownership</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK - Owner is updated</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Guid> TransferToolOwnershipAsync(System.Guid subscriptionId, TransferOwnershipRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/transferownership");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Guid>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 204)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("NoContent - Already owned by owner", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized - No valid authorization header", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this tool", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets template of the requested tool.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="masterDataOwnerId">id of the owner of master data</param>
        /// <param name="masterdataId">id of the masterdata for which a template should be returned</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="version">version for the schema used to generate the template.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InstanceDataTemplate> GetToolTemplateAsync(System.Guid subscriptionId, System.Guid masterDataOwnerId, System.Guid masterdataId, System.Guid? subjectSubscriptionId = null, string version = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (masterDataOwnerId == null)
                throw new System.ArgumentNullException("masterDataOwnerId");

            if (masterdataId == null)
                throw new System.ArgumentNullException("masterdataId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/template?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("masterDataOwnerId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(masterDataOwnerId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append(System.Uri.EscapeDataString("masterdataId") + "=").Append(System.Uri.EscapeDataString(ConvertToString(masterdataId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (version != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("version") + "=").Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InstanceDataTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets template of the requested tool.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="toolId">id of the type of tool for which an aggregation template should be returned</param>
        /// <param name="body">aggregation template request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AggregationTemplate> GetAggregationTemplateAsync(System.Guid subscriptionId, System.Guid toolId, AggregationTemplateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/aggregation/template");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AggregationTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a tools state
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="instanceDataId">id of the instancedata which should be changed</param>
        /// <param name="body">Instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ChangeToolStateByIdAsync(System.Guid subscriptionId, System.Guid instanceDataId, InstanceDateStateUpdate body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (instanceDataId == null)
                throw new System.ArgumentNullException("instanceDataId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{instanceDataId}/state");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceDataId}", System.Uri.EscapeDataString(ConvertToString(instanceDataId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Updates a tools aggregation properties
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="toolId">The unique id of the tool.</param>
        /// <param name="body">A json patch document (see http://jsonpatch.com/) that specifies the operations to apply to the instance data.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>No Content</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task UpdateAggregationByToolIdAsync(System.Guid subscriptionId, System.Guid toolId, System.Collections.Generic.IEnumerable<Operation> body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (toolId == null)
                throw new System.ArgumentNullException("toolId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{toolId}/aggregation");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{toolId}", System.Uri.EscapeDataString(ConvertToString(toolId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PATCH");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this instance data", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Plugs an instance data item to given space
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="spaceId">SpaceId to which instance item should be plugged</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PlugToolToSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid spaceId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            if (spaceId == null)
                throw new System.ArgumentNullException("spaceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{id}/spaces/{spaceId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{spaceId}", System.Uri.EscapeDataString(ConvertToString(spaceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Removes an instance data from its location.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of instance data item</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task RemoveToolFromSpaceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{id}/spaces");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Aggregates tool with other instance
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the tool</param>
        /// <param name="body">The aggregation create request</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task AggregateToolWithOtherInstanceAsync(System.Guid subscriptionId, System.Guid id, AggregationCreateRequest body, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{id}/aggregate");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Disaggregates tool and other instance
        /// </summary>
        /// <param name="subscriptionId">id of the subscription for which to create the tool.</param>
        /// <param name="id">ID of the tool</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DisaggregateToolAndOtherInstanceAsync(System.Guid subscriptionId, System.Guid id, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (id == null)
                throw new System.ArgumentNullException("id");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/{id}/disaggregate");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Returns the types for tools in the system.
        /// </summary>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfTypeInformation> GetToolTypesAsync(string subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/types");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfTypeInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ResultOfTypeInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves an number of instances by subscriptionId.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<int> GetToolsCountAsync(System.Guid subscriptionId, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/tools/count");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<int>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Search for instances.
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="body">The search request.</param>
        /// <param name="expectedLanguage">The header, which contains expectedLanguage will be used to return the manufacturer specific translation</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SearchListResultResponseOfSearchInstanceData> SearchInstanceDataAsync(System.Guid subscriptionId, GetSearchInstanceData body, string expectedLanguage = null, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/instancedata/search");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchListResultResponseOfSearchInstanceData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Search for manufacturers in TADAMO.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="search">The value to search.</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <param name="offset">Number of items to skip.</param>
        /// <param name="limit">Maximum number of items returned.</param>
        /// <param name="manufacturerKindFilter">Parameter to filter the result by manufacturer kind.</param>
        /// <returns>OK</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ResultOfSearchManufacturer> SearchManufacturersAsync(System.Guid subscriptionId, string search, System.Guid? subjectSubscriptionId = null, int? offset = null, int? limit = null, ManufacturerKindFilter? manufacturerKindFilter = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (search == null)
                throw new System.ArgumentNullException("search");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/manufacturers/search?");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("search") + "=").Append(System.Uri.EscapeDataString(ConvertToString(search, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (offset != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("offset") + "=").Append(System.Uri.EscapeDataString(ConvertToString(offset, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (manufacturerKindFilter != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("manufacturerKindFilter") + "=").Append(System.Uri.EscapeDataString(ConvertToString(manufacturerKindFilter, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ResultOfSearchManufacturer>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Search for masterdata.
        /// </summary>
        /// <param name="subscriptionId">Id of the customers subscription.</param>
        /// <param name="body">Request defining what to search</param>
        /// <param name="expectedLanguage">The header, which contains expectedLanguage will be used to return the manufacturer specific translation</param>
        /// <param name="subjectSubscriptionId">Specifies subscriptionId of the caller. If none is provided, it will be assumed that the caller is equal to the owner of the resource.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SearchListResultResponseOfSearchMasterData> SearchMasterDataAsync(System.Guid subscriptionId, GetSearchMasterData body, string expectedLanguage = null, System.Guid? subjectSubscriptionId = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/masterdata/search");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (expectedLanguage != null)
                        request_.Headers.TryAddWithoutValidation("expectedLanguage", ConvertToString(expectedLanguage, System.Globalization.CultureInfo.InvariantCulture));

                    if (subjectSubscriptionId != null)
                        request_.Headers.TryAddWithoutValidation("subjectSubscriptionId", ConvertToString(subjectSubscriptionId, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json-patch+json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("text/plain"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchListResultResponseOfSearchMasterData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Gets TADAMO instance data item by internal id
        /// </summary>
        /// <param name="subscriptionId">id of the subscription.</param>
        /// <param name="instanceId">ID of instance item</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task GetEtmlInstanceByIdAsync(System.Guid subscriptionId, System.Guid instanceId, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (instanceId == null)
                throw new System.ArgumentNullException("instanceId");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/subscriptions/{subscriptionId}/instancedata/{instanceId}");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{instanceId}", System.Uri.EscapeDataString(ConvertToString(instanceId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Unauthorized", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Forbidden - The caller has no access to this instance data", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new TadamoApiException("Error", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves historical instance data.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which data to retrieve.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<HistoricalListResponseOfHistoricalInstanceData> RequestHistoricalInstanceDataAsync(System.Guid subscriptionId, HistoricalInstanceDataRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/historicaldata/instancedata");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HistoricalListResponseOfHistoricalInstanceData>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves sharpening cycles for instances.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which cycles to retrieve.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<HistoricalListResponseOfSharpeningCycle> RequestSharpeningCyclesAsync(System.Guid subscriptionId, GetSharpeningCyclesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/historicaldata/instancedata/sharpeningcycles");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HistoricalListResponseOfSharpeningCycle>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Aggregates a parameter by sharpening cycles.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which parameter to aggregate.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<HistoricalListResponseOfSharpeningCycleAggregation> AggregateBySharpeningCyclesAsync(System.Guid subscriptionId, AggregateBySharpeningCycleRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/historicaldata/instancedata/sharpeningcycles/aggregate");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HistoricalListResponseOfSharpeningCycleAggregation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Retrieves the date when the instance was last put into sharpening.
        /// </summary>
        /// <param name="subscriptionId">Id of the subscription</param>
        /// <param name="body">Request that defines which data to retrieve.</param>
        /// <returns>Ok</returns>
        /// <exception cref="TadamoApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<HistoricalListResponseOfHistoricalDate> RequestLastBeginSharpeningDateAsync(System.Guid subscriptionId, GetDateOfLastSharpeningBeginRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (subscriptionId == null)
                throw new System.ArgumentNullException("subscriptionId");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/subscriptions/{subscriptionId}/historicaldata/instancedata/lastbeginsharpeningdate");
            urlBuilder_.Replace("{subscriptionId}", System.Uri.EscapeDataString(ConvertToString(subscriptionId, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HistoricalListResponseOfHistoricalDate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorInformation>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TadamoApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TadamoApiException<ErrorInformation>("Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new TadamoApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new TadamoApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Access
    {

        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"public")]
        Public = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"private")]
        Private = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Adapter : InstanceDataBase
    {
        [Newtonsoft.Json.JsonProperty("isAggregated", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsAggregated { get; set; }

        [Newtonsoft.Json.JsonProperty("toolId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? ToolId { get; set; }

    }

    /// <summary>
    /// Request to create an aggregation item.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AggregationCreateRequest
    {
        /// <summary>
        /// Gets or Sets adapter data id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("adapterId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid AdapterId { get; set; }

        /// <summary>
        /// Instance data item in json format
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aggregationPayload", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object AggregationPayload { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AggregationInfo
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("aggregatedInstances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InstanceData> AggregatedInstances { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AggregationTemplate
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Schema { get; set; }

    }

    /// <summary>
    /// Request to generate an aggregation template.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AggregationTemplateRequest
    {
        /// <summary>
        /// Gets or Sets adapter data id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("adapterId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid AdapterId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AssetBaseType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"tool")]
        Tool = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"material")]
        Material = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"adapter")]
        Adapter = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AvailabilityStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"notAvailable")]
        NotAvailable = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"available")]
        Available = 1,

    }

    /// <summary>
    /// Request to begin sharpening
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BeginSharpeningRequest
    {
        /// <summary>
        /// Gets or Sets TypeId
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sharpeningServiceId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid SharpeningServiceId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Blob
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("ownerId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid OwnerId { get; set; }

        [Newtonsoft.Json.JsonProperty("typeId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid TypeId { get; set; }

        [Newtonsoft.Json.JsonProperty("cultureName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CultureName { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Url { get; set; }

        [Newtonsoft.Json.JsonProperty("contentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContentType { get; set; }

        [Newtonsoft.Json.JsonProperty("originalOwnerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalOwnerId { get; set; }

        [Newtonsoft.Json.JsonProperty("originalBlobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalBlobId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BlobTypeInformation
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorInformation
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Details { get; set; }

    }

    /// <summary>
    /// Request to retrieve multiple instances by ids.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetInstancesRequest
    {
        /// <summary>
        /// Ids of the instances to retrieve.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceIds", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Guid> InstanceIds { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstanceData : InstanceDataBase
    {
        [Newtonsoft.Json.JsonProperty("toolId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? ToolId { get; set; }

        [Newtonsoft.Json.JsonProperty("isAggregated", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsAggregated { get; set; }

        [Newtonsoft.Json.JsonProperty("aggregationInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AggregationInfo AggregationInfo { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstanceDataBase
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("customCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomCode { get; set; }

        [Newtonsoft.Json.JsonProperty("externalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalId { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Owner Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("holder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Owner Holder { get; set; }

        [Newtonsoft.Json.JsonProperty("masterData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Masterdata MasterData { get; set; }

        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InstanceLocation Location { get; set; }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InstanceDataState State { get; set; }

        [Newtonsoft.Json.JsonProperty("assetBaseType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AssetBaseType AssetBaseType { get; set; }

        [Newtonsoft.Json.JsonProperty("availabilityStatus", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AvailabilityStatus AvailabilityStatus { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManufacturerMetadata ManufacturerMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ManufacturerTranslation> Translations { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SchemaInformation Schema { get; set; }

    }

    /// <summary>
    /// Request to create an instancedata item.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstanceDataCreateRequest
    {
        /// <summary>
        /// Gets or Sets Master data
        /// </summary>
        [Newtonsoft.Json.JsonProperty("masterdata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public MasterDataRequest Masterdata { get; set; } = new MasterDataRequest();

        /// <summary>
        /// Gets or Sets External id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("externalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalId { get; set; }

        /// <summary>
        /// Custom id which is unique in scope of a subscription/ owner
        /// </summary>
        [Newtonsoft.Json.JsonProperty("customCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomCode { get; set; }

        /// <summary>
        /// Instance data item in json format
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Payload { get; set; }

        /// <summary>
        /// Schema version which should be used to create the instance data
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemaVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^v\d+\.\d+.\d+$")]
        public string SchemaVersion { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InstanceDataState
    {

        [System.Runtime.Serialization.EnumMember(Value = @"active")]
        Active = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"archived")]
        Archived = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstanceDataTemplate
    {
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SchemaInformation Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManufacturerMetadata ManufacturerMetadata { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstanceDateStateUpdate
    {
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InstanceDataState State { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstanceLocation
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LocationInstance
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Machine
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        [Newtonsoft.Json.JsonProperty("instances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LocationInstance> Instances { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ManufacturerInformation
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerKind", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ManufacturerKind ManufacturerKind { get; set; }

        [Newtonsoft.Json.JsonProperty("blobs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Blob> Blobs { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ManufacturerKind
    {

        [System.Runtime.Serialization.EnumMember(Value = @"toolManufacturer")]
        ToolManufacturer = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"materialManufacturer")]
        MaterialManufacturer = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ManufacturerKindFilter
    {

        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"toolManufacturer")]
        ToolManufacturer = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"materialManufacturer")]
        MaterialManufacturer = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ManufacturerMetadata
    {
        [Newtonsoft.Json.JsonProperty("labelNames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> LabelNames { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ManufacturerTranslation
    {
        [Newtonsoft.Json.JsonProperty("cultureName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CultureName { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Masterdata
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("tadamoTypeId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid TadamoTypeId { get; set; }

        [Newtonsoft.Json.JsonProperty("usedInstancesCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int UsedInstancesCount { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManufacturerInformation Manufacturer { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Owner Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SchemaInformation Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("blobs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Blob> Blobs { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManufacturerMetadata ManufacturerMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ManufacturerTranslation> Translations { get; set; }

        [Newtonsoft.Json.JsonProperty("assetBaseType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AssetBaseType AssetBaseType { get; set; }

        [Newtonsoft.Json.JsonProperty("originalMasterDataId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalMasterDataId { get; set; }

        [Newtonsoft.Json.JsonProperty("originalOwnerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalOwnerId { get; set; }

        [Newtonsoft.Json.JsonProperty("regions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Regions { get; set; }

        [Newtonsoft.Json.JsonProperty("translationKeys", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Translation> TranslationKeys { get; set; }

    }

    /// <summary>
    /// Request to create a masterdata item
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MasterDataCreateRequest
    {
        /// <summary>
        /// Gets or Sets TypeId
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tadamoTypeId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid TadamoTypeId { get; set; }

        /// <summary>
        /// Master data item in json format
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Payload { get; set; }

        /// <summary>
        /// manufacturer id who created the item
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manufacturerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? ManufacturerId { get; set; }

        /// <summary>
        /// manufacturer who created the item.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manufacturer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OwnerCreate Manufacturer { get; set; }

        /// <summary>
        /// The array of regions of the master data.
        /// <br/>It contains Two-Letter-Iso-Region-Name like US,DE
        /// </summary>
        [Newtonsoft.Json.JsonProperty("regions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Regions { get; set; }

        /// <summary>
        /// schema version which should be used to create the master data
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schemaVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^v\d+\.\d+.\d+$")]
        public string SchemaVersion { get; set; }

    }

    /// <summary>
    /// Request that provides an info about master data
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MasterDataRequest
    {
        /// <summary>
        /// Gets or Sets Master data id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("masterdataOwnerId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MasterdataOwnerId { get; set; }

        /// <summary>
        /// Gets or Sets Master data id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("masterdataId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid MasterdataId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Material : InstanceDataBase
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Operation
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }

        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("op", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Op { get; set; }

        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string From { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Owner
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OwnerCreate
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerKind", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ManufacturerKind ManufacturerKind { get; set; }

    }

    /// <summary>
    /// Model for processdata sent from a machine.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProcessDataListRequest
    {
        /// <summary>
        /// List of processdata messages.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("processData", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ProcessDataMessage> ProcessData { get; set; } = new System.Collections.ObjectModel.Collection<ProcessDataMessage>();

    }

    /// <summary>
    /// A single processdata message.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProcessDataMessage
    {
        /// <summary>
        /// Path to the property to update.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameterPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParameterPath { get; set; }

        /// <summary>
        /// Process data payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Payload { get; set; }

        /// <summary>
        /// Timestamp that identifies the time when the processdata was created. If no timestamp is provided,
        /// <br/>the current servertime is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Timestamp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfInstanceData
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InstanceData> Data { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfBlobTypeInformation
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BlobTypeInformation> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfSchema
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Schema> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfSharpeningService
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SharpeningService> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfSpace
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Space> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfSystemSchemas
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SystemSchemas> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfTypeInformation
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TypeInformation> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Schema
    {
        [Newtonsoft.Json.JsonProperty("typeinformation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypeInformation Typeinformation { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Schema1 { get; set; }

        [Newtonsoft.Json.JsonProperty("instanceSchema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object InstanceSchema { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SchemaInformation
    {
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^v\d+\.\d+.\d+$")]
        public string Version { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SharpeningService
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Space
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        [Newtonsoft.Json.JsonProperty("locationType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SpaceLocationType LocationType { get; set; }

        [Newtonsoft.Json.JsonProperty("additionalProperties", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties { get; set; }

        [Newtonsoft.Json.JsonProperty("machines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Machine> Machines { get; set; }

        [Newtonsoft.Json.JsonProperty("instances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LocationInstance> Instances { get; set; }

        [Newtonsoft.Json.JsonProperty("childSpaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Space> ChildSpaces { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SpaceLocationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"group")]
        Group = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"root")]
        Root = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"warehouse")]
        Warehouse = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SystemSchema
    {
        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^v\d+\.\d+.\d+$")]
        public string Version { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SystemSchemas
    {
        [Newtonsoft.Json.JsonProperty("masterDataSchemas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SystemSchema> MasterDataSchemas { get; set; }

        [Newtonsoft.Json.JsonProperty("instanceDataSchemas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SystemSchema> InstanceDataSchemas { get; set; }

        [Newtonsoft.Json.JsonProperty("aggregationSchemas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SystemSchema> AggregationSchemas { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Tool : InstanceDataBase
    {
        [Newtonsoft.Json.JsonProperty("isAggregated", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsAggregated { get; set; }

        [Newtonsoft.Json.JsonProperty("aggregationInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AggregationInfo AggregationInfo { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TraversalDirection
    {

        [System.Runtime.Serialization.EnumMember(Value = @"up")]
        Up = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"down")]
        Down = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"upAndDown")]
        UpAndDown = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TypeInformation
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("schemaUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri SchemaUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("instanceSchemaUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri InstanceSchemaUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("aggregationSchemaUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri AggregationSchemaUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("subtypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TypeInformation> Subtypes { get; set; }

    }

    /// <summary>
    /// Request to transfer ownership from manufacturer to customer
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransferOwnershipRequest
    {
        /// <summary>
        /// manufacturer id who created the item
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manufacturerId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid ManufacturerId { get; set; }

        /// <summary>
        /// instance id
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceDataId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid InstanceDataId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Translation
    {
        [Newtonsoft.Json.JsonProperty("cultureName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CultureName { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Data { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AccessFilter
    {

        [System.Runtime.Serialization.EnumMember(Value = @"all")]
        All = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"public")]
        Public = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"private")]
        Private = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FilterOperation
    {

        [System.Runtime.Serialization.EnumMember(Value = @"in")]
        In = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"equal")]
        Equal = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThan")]
        LessThan = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThanOrEqual")]
        LessThanOrEqual = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterThan")]
        GreaterThan = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterOrEqual")]
        GreaterOrEqual = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"between")]
        Between = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SearchFields
    {

        [System.Runtime.Serialization.EnumMember(Value = @"productName")]
        ProductName = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"displayName")]
        DisplayName = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"colorDescription")]
        ColorDescription = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchFilter
    {
        [Newtonsoft.Json.JsonProperty("parameterName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParameterName { get; set; }

        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FilterOperation Operation { get; set; }

        [Newtonsoft.Json.JsonProperty("minValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinValue { get; set; }

        [Newtonsoft.Json.JsonProperty("maxValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxValue { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Value { get; set; }

        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<double> Values { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchInstanceDataRequest
    {
        [Newtonsoft.Json.JsonProperty("search", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Search { get; set; }

        [Newtonsoft.Json.JsonProperty("language", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Language { get; set; }

        [Newtonsoft.Json.JsonProperty("searchFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<SearchFields> SearchFields { get; set; }

        [Newtonsoft.Json.JsonProperty("offset", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Offset { get; set; }

        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Limit { get; set; }

        [Newtonsoft.Json.JsonProperty("filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchFilter> Filters { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetSearchDataDtoBase
    {
        [Newtonsoft.Json.JsonProperty("search", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Search { get; set; }

        [Newtonsoft.Json.JsonProperty("locale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Locale { get; set; }

        [Newtonsoft.Json.JsonProperty("searchFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<SearchFields> SearchFields { get; set; }

        [Newtonsoft.Json.JsonProperty("offset", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Offset { get; set; }

        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Limit { get; set; }

        [Newtonsoft.Json.JsonProperty("assetBaseTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<AssetBaseType> AssetBaseTypes { get; set; }

        [Newtonsoft.Json.JsonProperty("access", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AccessFilter Access { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Guid> ManufacturerIds { get; set; }

        [Newtonsoft.Json.JsonProperty("typeIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Guid> TypeIds { get; set; }

        [Newtonsoft.Json.JsonProperty("regions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Regions { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetSearchMasterData : GetSearchDataDtoBase
    {
        [Newtonsoft.Json.JsonProperty("payloadFilters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PayloadSearchFilter> PayloadFilters { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetSearchInstanceData : GetSearchDataDtoBase
    {
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InstanceDataState? State { get; set; }

        [Newtonsoft.Json.JsonProperty("isAggregated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? IsAggregated { get; set; }

        [Newtonsoft.Json.JsonProperty("customCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomCode { get; set; }

        [Newtonsoft.Json.JsonProperty("externalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalId { get; set; }

        [Newtonsoft.Json.JsonProperty("payloadFilters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InstancePayloadSearchFilter> PayloadFilters { get; set; }

        [Newtonsoft.Json.JsonProperty("locationIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> LocationIds { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PayloadSearchFilter
    {
        [Newtonsoft.Json.JsonProperty("parameterName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParameterName { get; set; }

        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FilterOperation Operation { get; set; }

        [Newtonsoft.Json.JsonProperty("minValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinValue { get; set; }

        [Newtonsoft.Json.JsonProperty("maxValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxValue { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PayloadType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"masterdata")]
        Masterdata = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"instanceData")]
        InstanceData = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"toolSet")]
        ToolSet = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InstancePayloadSearchFilter : PayloadSearchFilter
    {
        [Newtonsoft.Json.JsonProperty("payloadType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PayloadType PayloadType { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResultOfSearchManufacturer
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchManufacturer> Data { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    /// <summary>
    /// Result of a search request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchListResultResponseOfSearchInstanceData
    {
        /// <summary>
        /// The items found by the search
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchInstanceData> Data { get; set; }

        /// <summary>
        /// Relevant translations for the contained items.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    /// <summary>
    /// Result of a search request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchListResultResponseOfSearchMasterData
    {
        /// <summary>
        /// The items found by the search
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchMasterData> Data { get; set; }

        /// <summary>
        /// Relevant translations for the contained items.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.ICollection<ManufacturerTranslation>> Translations { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchAggregationInfo
    {
        [Newtonsoft.Json.JsonProperty("schemaUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri SchemaUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("aggregatedInstances", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchInstanceData> AggregatedInstances { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchBlob
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("ownerId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid OwnerId { get; set; }

        [Newtonsoft.Json.JsonProperty("typeId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid TypeId { get; set; }

        [Newtonsoft.Json.JsonProperty("cultureName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CultureName { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Url { get; set; }

        [Newtonsoft.Json.JsonProperty("contentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContentType { get; set; }

        [Newtonsoft.Json.JsonProperty("originalOwnerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalOwnerId { get; set; }

        [Newtonsoft.Json.JsonProperty("originalBlobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalBlobId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchInstanceData : SearchInstanceDataBase
    {
        [Newtonsoft.Json.JsonProperty("isAggregated", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsAggregated { get; set; }

        [Newtonsoft.Json.JsonProperty("aggregationInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SearchAggregationInfo AggregationInfo { get; set; }

        [Newtonsoft.Json.JsonProperty("toolId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? ToolId { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchInstanceDataBase
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("customCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomCode { get; set; }

        [Newtonsoft.Json.JsonProperty("externalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalId { get; set; }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SearchOwner Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("holder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SearchOwner Holder { get; set; }

        [Newtonsoft.Json.JsonProperty("masterData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SearchMasterData MasterData { get; set; }

        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SearchInstanceLocation Location { get; set; }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InstanceDataState State { get; set; }

        [Newtonsoft.Json.JsonProperty("assetBaseType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AssetBaseType AssetBaseType { get; set; }

        [Newtonsoft.Json.JsonProperty("availabilityStatus", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AvailabilityStatus AvailabilityStatus { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManufacturerMetadata ManufacturerMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("translations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ManufacturerTranslation> Translations { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SchemaInformation Schema { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchInstanceLocation
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchManufacturer
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerKind", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ManufacturerKind ManufacturerKind { get; set; }

        [Newtonsoft.Json.JsonProperty("blobs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchBlob> Blobs { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchManufacturerOfMasterData
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("blobs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchBlob> Blobs { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchMasterData
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("tadamoTypeId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid TadamoTypeId { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SearchManufacturerOfMasterData Manufacturer { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SearchOwner Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SchemaInformation Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("blobs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SearchBlob> Blobs { get; set; }

        [Newtonsoft.Json.JsonProperty("manufacturerMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ManufacturerMetadata ManufacturerMetadata { get; set; }

        [Newtonsoft.Json.JsonProperty("assetBaseType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AssetBaseType AssetBaseType { get; set; }

        [Newtonsoft.Json.JsonProperty("originalMasterDataId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalMasterDataId { get; set; }

        [Newtonsoft.Json.JsonProperty("originalOwnerId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid? OriginalOwnerId { get; set; }

        [Newtonsoft.Json.JsonProperty("regions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Regions { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchOwner
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Guid Id { get; set; }

    }

    /// <summary>
    /// Request to retrieve historical instance data.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalInstanceDataRequest
    {
        /// <summary>
        /// Only instancedata equal or newer than this is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? From { get; set; }

        /// <summary>
        /// Only instancedata older than this is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? To { get; set; }

        /// <summary>
        /// Limits the number of items returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(1, 1000)]
        public int Limit { get; set; } = 200;

        /// <summary>
        /// Filters the returned data by instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Guid> InstanceIds { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalLocationValue
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalMachineValue
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("tmid", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tmid { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalOwnerValue
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid Id { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalSchema
    {
        [Newtonsoft.Json.JsonProperty("provider", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Provider { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalInstanceData
    {
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid InstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("masterDataId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid MasterDataId { get; set; }

        [Newtonsoft.Json.JsonProperty("typeId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid TypeId { get; set; }

        [Newtonsoft.Json.JsonProperty("customCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CustomCode { get; set; }

        [Newtonsoft.Json.JsonProperty("externalId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalId { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object Data { get; set; }

        [Newtonsoft.Json.JsonProperty("location", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HistoricalLocationValue Location { get; set; }

        [Newtonsoft.Json.JsonProperty("machine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HistoricalMachineValue Machine { get; set; }

        [Newtonsoft.Json.JsonProperty("holder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HistoricalOwnerValue Holder { get; set; }

        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public InstanceDataState State { get; set; }

        [Newtonsoft.Json.JsonProperty("schema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HistoricalSchema Schema { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset Timestamp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalListResponseOfHistoricalInstanceData
    {
        [Newtonsoft.Json.JsonProperty("totalCount", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long TotalCount { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricalInstanceData> Data { get; set; }

    }

    /// <summary>
    /// Request to retrieve the date of the last sharpening begin
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetDateOfLastSharpeningBeginRequest
    {
        /// <summary>
        /// Filters the returned data by instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Guid> InstanceIds { get; set; }

    }

    /// <summary>
    /// response model for a collection of items
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalListResponseOfHistoricalDate
    {
        /// <summary>
        /// The items.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HistoricalDate> Data { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalDate
    {
        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid InstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("timestamp", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset Timestamp { get; set; }

    }

    /// <summary>
    /// Request to retrieve sharpening cycles.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetSharpeningCyclesRequest
    {
        /// <summary>
        /// Only data equal or newer than this is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? From { get; set; }

        /// <summary>
        /// Only data equal or older than this is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? To { get; set; }

        /// <summary>
        /// Filters the returned data by instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Guid> InstanceIds { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SharpeningCycleDto
    {
        [Newtonsoft.Json.JsonProperty("cycleIndex", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int CycleIndex { get; set; }

        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid InstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset StartDate { get; set; }

        [Newtonsoft.Json.JsonProperty("endDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndDate { get; set; }

    }

    /// <summary>
    /// response model for a collection of items
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalListResponseOfSharpeningCycle
    {
        /// <summary>
        /// The items.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SharpeningCycleDto> Data { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AggregationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"sum")]
        Sum = 0,

    }

    /// <summary>
    /// Request to retrieve sharpening cycles.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AggregateBySharpeningCycleRequest
    {
        /// <summary>
        /// Only data equal or newer than this is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? From { get; set; }

        /// <summary>
        /// Only data older than this is returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("to", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? To { get; set; }

        /// <summary>
        /// Filters the returned data by instance
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<System.Guid> InstanceIds { get; set; }

        /// <summary>
        /// Specifies the process data parameter that should be aggregated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameterKey", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ParameterKey { get; set; }

        /// <summary>
        /// Specifies how the parameter values should be aggregated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aggregationType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AggregationType AggregationType { get; set; }

        [Newtonsoft.Json.JsonProperty("groupBy", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GroupByRequest GroupBy { get; set; }

    }

    /// <summary>
    /// Specifies the grouping
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GroupByRequest
    {
        /// <summary>
        /// Property name  inside the metadata after which the response will be grouped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadataKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MetadataKey { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AggregatedParameterDto
    {
        [Newtonsoft.Json.JsonProperty("aggregationType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AggregationType AggregationType { get; set; }

        [Newtonsoft.Json.JsonProperty("parameterKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParameterKey { get; set; }

        [Newtonsoft.Json.JsonProperty("unit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Unit { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SharpeningCycleAggregationDto
    {
        [Newtonsoft.Json.JsonProperty("aggregationValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AggregatedParameterDto AggregationValue { get; set; }

        [Newtonsoft.Json.JsonProperty("groupKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupKey { get; set; }

        [Newtonsoft.Json.JsonProperty("cycleIndex", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int CycleIndex { get; set; }

        [Newtonsoft.Json.JsonProperty("instanceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Guid InstanceId { get; set; }

        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset StartDate { get; set; }

        [Newtonsoft.Json.JsonProperty("endDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndDate { get; set; }

    }

    /// <summary>
    /// response model for a collection of items
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HistoricalListResponseOfSharpeningCycleAggregation
    {
        /// <summary>
        /// The items.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SharpeningCycleAggregationDto> Data { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileParameter
    {
        public FileParameter(System.IO.Stream data)
            : this (data, null, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName)
            : this (data, fileName, null)
        {
        }

        public FileParameter(System.IO.Stream data, string fileName, string contentType)
        {
            Data = data;
            FileName = fileName;
            ContentType = contentType;
        }

        public System.IO.Stream Data { get; private set; }

        public string FileName { get; private set; }

        public string ContentType { get; private set; }
    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TadamoApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public TadamoApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TadamoApiException<TResult> : TadamoApiException
    {
        public TResult Result { get; private set; }

        public TadamoApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
#pragma warning restore 3016
#pragma warning restore 8603